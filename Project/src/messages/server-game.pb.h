// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server-game.proto

#ifndef PROTOBUF_server_2dgame_2eproto__INCLUDED
#define PROTOBUF_server_2dgame_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace orwell {
namespace messages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_server_2dgame_2eproto();
void protobuf_AssignDesc_server_2dgame_2eproto();
void protobuf_ShutdownFile_server_2dgame_2eproto();

class Team;
class GameState;
class Welcome;
class Goodbye;
class Access;
class GiveVideo;
class Start;
class Stop;

enum EnumTeam {
  RED = 0,
  BLU = 1
};
bool EnumTeam_IsValid(int value);
const EnumTeam EnumTeam_MIN = RED;
const EnumTeam EnumTeam_MAX = BLU;
const int EnumTeam_ARRAYSIZE = EnumTeam_MAX + 1;

// ===================================================================

class Team : public ::google_public::protobuf::MessageLite {
 public:
  Team();
  virtual ~Team();

  Team(const Team& from);

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }

  static const Team& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Team* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Team* other);

  // implements Message ----------------------------------------------

  Team* New() const;
  void CheckTypeAndMergeFrom(const ::google_public::protobuf::MessageLite& from);
  void CopyFrom(const Team& from);
  void MergeFrom(const Team& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 score = 1;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 1;
  inline ::google_public::protobuf::uint32 score() const;
  inline void set_score(::google_public::protobuf::uint32 value);

  // optional uint32 num_players = 2;
  inline bool has_num_players() const;
  inline void clear_num_players();
  static const int kNumPlayersFieldNumber = 2;
  inline ::google_public::protobuf::uint32 num_players() const;
  inline void set_num_players(::google_public::protobuf::uint32 value);

  // repeated string players = 3;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 3;
  inline const ::std::string& players(int index) const;
  inline ::std::string* mutable_players(int index);
  inline void set_players(int index, const ::std::string& value);
  inline void set_players(int index, const char* value);
  inline void set_players(int index, const char* value, size_t size);
  inline ::std::string* add_players();
  inline void add_players(const ::std::string& value);
  inline void add_players(const char* value);
  inline void add_players(const char* value, size_t size);
  inline const ::google_public::protobuf::RepeatedPtrField< ::std::string>& players() const;
  inline ::google_public::protobuf::RepeatedPtrField< ::std::string>* mutable_players();

  // @@protoc_insertion_point(class_scope:orwell.messages.Team)
 private:
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_num_players();
  inline void clear_has_num_players();

  ::google_public::protobuf::uint32 score_;
  ::google_public::protobuf::uint32 num_players_;
  ::google_public::protobuf::RepeatedPtrField< ::std::string> players_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_server_2dgame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_server_2dgame_2eproto();
  #endif
  friend void protobuf_AssignDesc_server_2dgame_2eproto();
  friend void protobuf_ShutdownFile_server_2dgame_2eproto();

  void InitAsDefaultInstance();
  static Team* default_instance_;
};
// -------------------------------------------------------------------

class GameState : public ::google_public::protobuf::MessageLite {
 public:
  GameState();
  virtual ~GameState();

  GameState(const GameState& from);

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }

  static const GameState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GameState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GameState* other);

  // implements Message ----------------------------------------------

  GameState* New() const;
  void CheckTypeAndMergeFrom(const ::google_public::protobuf::MessageLite& from);
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool playing = 1;
  inline bool has_playing() const;
  inline void clear_playing();
  static const int kPlayingFieldNumber = 1;
  inline bool playing() const;
  inline void set_playing(bool value);

  // optional uint64 seconds = 2;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  inline ::google_public::protobuf::uint64 seconds() const;
  inline void set_seconds(::google_public::protobuf::uint64 value);

  // optional .orwell.messages.Team blu = 3;
  inline bool has_blu() const;
  inline void clear_blu();
  static const int kBluFieldNumber = 3;
  inline const ::orwell::messages::Team& blu() const;
  inline ::orwell::messages::Team* mutable_blu();
  inline ::orwell::messages::Team* release_blu();
  inline void set_allocated_blu(::orwell::messages::Team* blu);

  // optional .orwell.messages.Team red = 4;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 4;
  inline const ::orwell::messages::Team& red() const;
  inline ::orwell::messages::Team* mutable_red();
  inline ::orwell::messages::Team* release_red();
  inline void set_allocated_red(::orwell::messages::Team* red);

  // optional .orwell.messages.EnumTeam winner = 5;
  inline bool has_winner() const;
  inline void clear_winner();
  static const int kWinnerFieldNumber = 5;
  inline ::orwell::messages::EnumTeam winner() const;
  inline void set_winner(::orwell::messages::EnumTeam value);

  // @@protoc_insertion_point(class_scope:orwell.messages.GameState)
 private:
  inline void set_has_playing();
  inline void clear_has_playing();
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_blu();
  inline void clear_has_blu();
  inline void set_has_red();
  inline void clear_has_red();
  inline void set_has_winner();
  inline void clear_has_winner();

  ::google_public::protobuf::uint64 seconds_;
  ::orwell::messages::Team* blu_;
  bool playing_;
  int winner_;
  ::orwell::messages::Team* red_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_server_2dgame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_server_2dgame_2eproto();
  #endif
  friend void protobuf_AssignDesc_server_2dgame_2eproto();
  friend void protobuf_ShutdownFile_server_2dgame_2eproto();

  void InitAsDefaultInstance();
  static GameState* default_instance_;
};
// -------------------------------------------------------------------

class Welcome : public ::google_public::protobuf::MessageLite {
 public:
  Welcome();
  virtual ~Welcome();

  Welcome(const Welcome& from);

  inline Welcome& operator=(const Welcome& from) {
    CopyFrom(from);
    return *this;
  }

  static const Welcome& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Welcome* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Welcome* other);

  // implements Message ----------------------------------------------

  Welcome* New() const;
  void CheckTypeAndMergeFrom(const ::google_public::protobuf::MessageLite& from);
  void CopyFrom(const Welcome& from);
  void MergeFrom(const Welcome& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string robot = 1;
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 1;
  inline const ::std::string& robot() const;
  inline void set_robot(const ::std::string& value);
  inline void set_robot(const char* value);
  inline void set_robot(const char* value, size_t size);
  inline ::std::string* mutable_robot();
  inline ::std::string* release_robot();
  inline void set_allocated_robot(::std::string* robot);

  // required .orwell.messages.EnumTeam team = 2;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 2;
  inline ::orwell::messages::EnumTeam team() const;
  inline void set_team(::orwell::messages::EnumTeam value);

  // optional .orwell.messages.GameState game_state = 3;
  inline bool has_game_state() const;
  inline void clear_game_state();
  static const int kGameStateFieldNumber = 3;
  inline const ::orwell::messages::GameState& game_state() const;
  inline ::orwell::messages::GameState* mutable_game_state();
  inline ::orwell::messages::GameState* release_game_state();
  inline void set_allocated_game_state(::orwell::messages::GameState* game_state);

  // @@protoc_insertion_point(class_scope:orwell.messages.Welcome)
 private:
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_game_state();
  inline void clear_has_game_state();

  ::std::string* robot_;
  ::orwell::messages::GameState* game_state_;
  int team_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_server_2dgame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_server_2dgame_2eproto();
  #endif
  friend void protobuf_AssignDesc_server_2dgame_2eproto();
  friend void protobuf_ShutdownFile_server_2dgame_2eproto();

  void InitAsDefaultInstance();
  static Welcome* default_instance_;
};
// -------------------------------------------------------------------

class Goodbye : public ::google_public::protobuf::MessageLite {
 public:
  Goodbye();
  virtual ~Goodbye();

  Goodbye(const Goodbye& from);

  inline Goodbye& operator=(const Goodbye& from) {
    CopyFrom(from);
    return *this;
  }

  static const Goodbye& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Goodbye* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Goodbye* other);

  // implements Message ----------------------------------------------

  Goodbye* New() const;
  void CheckTypeAndMergeFrom(const ::google_public::protobuf::MessageLite& from);
  void CopyFrom(const Goodbye& from);
  void MergeFrom(const Goodbye& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:orwell.messages.Goodbye)
 private:


  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_server_2dgame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_server_2dgame_2eproto();
  #endif
  friend void protobuf_AssignDesc_server_2dgame_2eproto();
  friend void protobuf_ShutdownFile_server_2dgame_2eproto();

  void InitAsDefaultInstance();
  static Goodbye* default_instance_;
};
// -------------------------------------------------------------------

class Access : public ::google_public::protobuf::MessageLite {
 public:
  Access();
  virtual ~Access();

  Access(const Access& from);

  inline Access& operator=(const Access& from) {
    CopyFrom(from);
    return *this;
  }

  static const Access& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Access* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Access* other);

  // implements Message ----------------------------------------------

  Access* New() const;
  void CheckTypeAndMergeFrom(const ::google_public::protobuf::MessageLite& from);
  void CopyFrom(const Access& from);
  void MergeFrom(const Access& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google_public::protobuf::uint32 port() const;
  inline void set_port(::google_public::protobuf::uint32 value);

  // optional string ip = 2 [default = ""];
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:orwell.messages.Access)
 private:
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::std::string* ip_;
  ::google_public::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_server_2dgame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_server_2dgame_2eproto();
  #endif
  friend void protobuf_AssignDesc_server_2dgame_2eproto();
  friend void protobuf_ShutdownFile_server_2dgame_2eproto();

  void InitAsDefaultInstance();
  static Access* default_instance_;
};
// -------------------------------------------------------------------

class GiveVideo : public ::google_public::protobuf::MessageLite {
 public:
  GiveVideo();
  virtual ~GiveVideo();

  GiveVideo(const GiveVideo& from);

  inline GiveVideo& operator=(const GiveVideo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiveVideo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiveVideo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiveVideo* other);

  // implements Message ----------------------------------------------

  GiveVideo* New() const;
  void CheckTypeAndMergeFrom(const ::google_public::protobuf::MessageLite& from);
  void CopyFrom(const GiveVideo& from);
  void MergeFrom(const GiveVideo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:orwell.messages.GiveVideo)
 private:


  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_server_2dgame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_server_2dgame_2eproto();
  #endif
  friend void protobuf_AssignDesc_server_2dgame_2eproto();
  friend void protobuf_ShutdownFile_server_2dgame_2eproto();

  void InitAsDefaultInstance();
  static GiveVideo* default_instance_;
};
// -------------------------------------------------------------------

class Start : public ::google_public::protobuf::MessageLite {
 public:
  Start();
  virtual ~Start();

  Start(const Start& from);

  inline Start& operator=(const Start& from) {
    CopyFrom(from);
    return *this;
  }

  static const Start& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Start* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Start* other);

  // implements Message ----------------------------------------------

  Start* New() const;
  void CheckTypeAndMergeFrom(const ::google_public::protobuf::MessageLite& from);
  void CopyFrom(const Start& from);
  void MergeFrom(const Start& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .orwell.messages.GameState game_state = 1;
  inline bool has_game_state() const;
  inline void clear_game_state();
  static const int kGameStateFieldNumber = 1;
  inline const ::orwell::messages::GameState& game_state() const;
  inline ::orwell::messages::GameState* mutable_game_state();
  inline ::orwell::messages::GameState* release_game_state();
  inline void set_allocated_game_state(::orwell::messages::GameState* game_state);

  // @@protoc_insertion_point(class_scope:orwell.messages.Start)
 private:
  inline void set_has_game_state();
  inline void clear_has_game_state();

  ::orwell::messages::GameState* game_state_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_server_2dgame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_server_2dgame_2eproto();
  #endif
  friend void protobuf_AssignDesc_server_2dgame_2eproto();
  friend void protobuf_ShutdownFile_server_2dgame_2eproto();

  void InitAsDefaultInstance();
  static Start* default_instance_;
};
// -------------------------------------------------------------------

class Stop : public ::google_public::protobuf::MessageLite {
 public:
  Stop();
  virtual ~Stop();

  Stop(const Stop& from);

  inline Stop& operator=(const Stop& from) {
    CopyFrom(from);
    return *this;
  }

  static const Stop& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Stop* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Stop* other);

  // implements Message ----------------------------------------------

  Stop* New() const;
  void CheckTypeAndMergeFrom(const ::google_public::protobuf::MessageLite& from);
  void CopyFrom(const Stop& from);
  void MergeFrom(const Stop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google_public::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google_public::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool shutdown = 1 [default = false];
  inline bool has_shutdown() const;
  inline void clear_shutdown();
  static const int kShutdownFieldNumber = 1;
  inline bool shutdown() const;
  inline void set_shutdown(bool value);

  // optional bool video = 2 [default = true];
  inline bool has_video() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 2;
  inline bool video() const;
  inline void set_video(bool value);

  // @@protoc_insertion_point(class_scope:orwell.messages.Stop)
 private:
  inline void set_has_shutdown();
  inline void clear_has_shutdown();
  inline void set_has_video();
  inline void clear_has_video();

  bool shutdown_;
  bool video_;

  mutable int _cached_size_;
  ::google_public::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_server_2dgame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_server_2dgame_2eproto();
  #endif
  friend void protobuf_AssignDesc_server_2dgame_2eproto();
  friend void protobuf_ShutdownFile_server_2dgame_2eproto();

  void InitAsDefaultInstance();
  static Stop* default_instance_;
};
// ===================================================================


// ===================================================================

// Team

// optional uint32 score = 1;
inline bool Team::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Team::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Team::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Team::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google_public::protobuf::uint32 Team::score() const {
  return score_;
}
inline void Team::set_score(::google_public::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional uint32 num_players = 2;
inline bool Team::has_num_players() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Team::set_has_num_players() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Team::clear_has_num_players() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Team::clear_num_players() {
  num_players_ = 0u;
  clear_has_num_players();
}
inline ::google_public::protobuf::uint32 Team::num_players() const {
  return num_players_;
}
inline void Team::set_num_players(::google_public::protobuf::uint32 value) {
  set_has_num_players();
  num_players_ = value;
}

// repeated string players = 3;
inline int Team::players_size() const {
  return players_.size();
}
inline void Team::clear_players() {
  players_.Clear();
}
inline const ::std::string& Team::players(int index) const {
  return players_.Get(index);
}
inline ::std::string* Team::mutable_players(int index) {
  return players_.Mutable(index);
}
inline void Team::set_players(int index, const ::std::string& value) {
  players_.Mutable(index)->assign(value);
}
inline void Team::set_players(int index, const char* value) {
  players_.Mutable(index)->assign(value);
}
inline void Team::set_players(int index, const char* value, size_t size) {
  players_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Team::add_players() {
  return players_.Add();
}
inline void Team::add_players(const ::std::string& value) {
  players_.Add()->assign(value);
}
inline void Team::add_players(const char* value) {
  players_.Add()->assign(value);
}
inline void Team::add_players(const char* value, size_t size) {
  players_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google_public::protobuf::RepeatedPtrField< ::std::string>&
Team::players() const {
  return players_;
}
inline ::google_public::protobuf::RepeatedPtrField< ::std::string>*
Team::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// GameState

// required bool playing = 1;
inline bool GameState::has_playing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameState::set_has_playing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameState::clear_has_playing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameState::clear_playing() {
  playing_ = false;
  clear_has_playing();
}
inline bool GameState::playing() const {
  return playing_;
}
inline void GameState::set_playing(bool value) {
  set_has_playing();
  playing_ = value;
}

// optional uint64 seconds = 2;
inline bool GameState::has_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameState::set_has_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameState::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameState::clear_seconds() {
  seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_seconds();
}
inline ::google_public::protobuf::uint64 GameState::seconds() const {
  return seconds_;
}
inline void GameState::set_seconds(::google_public::protobuf::uint64 value) {
  set_has_seconds();
  seconds_ = value;
}

// optional .orwell.messages.Team blu = 3;
inline bool GameState::has_blu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameState::set_has_blu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameState::clear_has_blu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameState::clear_blu() {
  if (blu_ != NULL) blu_->::orwell::messages::Team::Clear();
  clear_has_blu();
}
inline const ::orwell::messages::Team& GameState::blu() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return blu_ != NULL ? *blu_ : *default_instance().blu_;
#else
  return blu_ != NULL ? *blu_ : *default_instance_->blu_;
#endif
}
inline ::orwell::messages::Team* GameState::mutable_blu() {
  set_has_blu();
  if (blu_ == NULL) blu_ = new ::orwell::messages::Team;
  return blu_;
}
inline ::orwell::messages::Team* GameState::release_blu() {
  clear_has_blu();
  ::orwell::messages::Team* temp = blu_;
  blu_ = NULL;
  return temp;
}
inline void GameState::set_allocated_blu(::orwell::messages::Team* blu) {
  delete blu_;
  blu_ = blu;
  if (blu) {
    set_has_blu();
  } else {
    clear_has_blu();
  }
}

// optional .orwell.messages.Team red = 4;
inline bool GameState::has_red() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameState::set_has_red() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameState::clear_has_red() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameState::clear_red() {
  if (red_ != NULL) red_->::orwell::messages::Team::Clear();
  clear_has_red();
}
inline const ::orwell::messages::Team& GameState::red() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return red_ != NULL ? *red_ : *default_instance().red_;
#else
  return red_ != NULL ? *red_ : *default_instance_->red_;
#endif
}
inline ::orwell::messages::Team* GameState::mutable_red() {
  set_has_red();
  if (red_ == NULL) red_ = new ::orwell::messages::Team;
  return red_;
}
inline ::orwell::messages::Team* GameState::release_red() {
  clear_has_red();
  ::orwell::messages::Team* temp = red_;
  red_ = NULL;
  return temp;
}
inline void GameState::set_allocated_red(::orwell::messages::Team* red) {
  delete red_;
  red_ = red;
  if (red) {
    set_has_red();
  } else {
    clear_has_red();
  }
}

// optional .orwell.messages.EnumTeam winner = 5;
inline bool GameState::has_winner() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameState::set_has_winner() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameState::clear_has_winner() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameState::clear_winner() {
  winner_ = 0;
  clear_has_winner();
}
inline ::orwell::messages::EnumTeam GameState::winner() const {
  return static_cast< ::orwell::messages::EnumTeam >(winner_);
}
inline void GameState::set_winner(::orwell::messages::EnumTeam value) {
  assert(::orwell::messages::EnumTeam_IsValid(value));
  set_has_winner();
  winner_ = value;
}

// -------------------------------------------------------------------

// Welcome

// required string robot = 1;
inline bool Welcome::has_robot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Welcome::set_has_robot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Welcome::clear_has_robot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Welcome::clear_robot() {
  if (robot_ != &::google_public::protobuf::internal::kEmptyString) {
    robot_->clear();
  }
  clear_has_robot();
}
inline const ::std::string& Welcome::robot() const {
  return *robot_;
}
inline void Welcome::set_robot(const ::std::string& value) {
  set_has_robot();
  if (robot_ == &::google_public::protobuf::internal::kEmptyString) {
    robot_ = new ::std::string;
  }
  robot_->assign(value);
}
inline void Welcome::set_robot(const char* value) {
  set_has_robot();
  if (robot_ == &::google_public::protobuf::internal::kEmptyString) {
    robot_ = new ::std::string;
  }
  robot_->assign(value);
}
inline void Welcome::set_robot(const char* value, size_t size) {
  set_has_robot();
  if (robot_ == &::google_public::protobuf::internal::kEmptyString) {
    robot_ = new ::std::string;
  }
  robot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Welcome::mutable_robot() {
  set_has_robot();
  if (robot_ == &::google_public::protobuf::internal::kEmptyString) {
    robot_ = new ::std::string;
  }
  return robot_;
}
inline ::std::string* Welcome::release_robot() {
  clear_has_robot();
  if (robot_ == &::google_public::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = robot_;
    robot_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Welcome::set_allocated_robot(::std::string* robot) {
  if (robot_ != &::google_public::protobuf::internal::kEmptyString) {
    delete robot_;
  }
  if (robot) {
    set_has_robot();
    robot_ = robot;
  } else {
    clear_has_robot();
    robot_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
  }
}

// required .orwell.messages.EnumTeam team = 2;
inline bool Welcome::has_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Welcome::set_has_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Welcome::clear_has_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Welcome::clear_team() {
  team_ = 0;
  clear_has_team();
}
inline ::orwell::messages::EnumTeam Welcome::team() const {
  return static_cast< ::orwell::messages::EnumTeam >(team_);
}
inline void Welcome::set_team(::orwell::messages::EnumTeam value) {
  assert(::orwell::messages::EnumTeam_IsValid(value));
  set_has_team();
  team_ = value;
}

// optional .orwell.messages.GameState game_state = 3;
inline bool Welcome::has_game_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Welcome::set_has_game_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Welcome::clear_has_game_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Welcome::clear_game_state() {
  if (game_state_ != NULL) game_state_->::orwell::messages::GameState::Clear();
  clear_has_game_state();
}
inline const ::orwell::messages::GameState& Welcome::game_state() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return game_state_ != NULL ? *game_state_ : *default_instance().game_state_;
#else
  return game_state_ != NULL ? *game_state_ : *default_instance_->game_state_;
#endif
}
inline ::orwell::messages::GameState* Welcome::mutable_game_state() {
  set_has_game_state();
  if (game_state_ == NULL) game_state_ = new ::orwell::messages::GameState;
  return game_state_;
}
inline ::orwell::messages::GameState* Welcome::release_game_state() {
  clear_has_game_state();
  ::orwell::messages::GameState* temp = game_state_;
  game_state_ = NULL;
  return temp;
}
inline void Welcome::set_allocated_game_state(::orwell::messages::GameState* game_state) {
  delete game_state_;
  game_state_ = game_state;
  if (game_state) {
    set_has_game_state();
  } else {
    clear_has_game_state();
  }
}

// -------------------------------------------------------------------

// Goodbye

// -------------------------------------------------------------------

// Access

// required uint32 port = 1;
inline bool Access::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Access::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Access::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Access::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google_public::protobuf::uint32 Access::port() const {
  return port_;
}
inline void Access::set_port(::google_public::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string ip = 2 [default = ""];
inline bool Access::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Access::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Access::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Access::clear_ip() {
  if (ip_ != &::google_public::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Access::ip() const {
  return *ip_;
}
inline void Access::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google_public::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Access::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google_public::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Access::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google_public::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Access::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google_public::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Access::release_ip() {
  clear_has_ip();
  if (ip_ == &::google_public::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Access::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google_public::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google_public::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GiveVideo

// -------------------------------------------------------------------

// Start

// optional .orwell.messages.GameState game_state = 1;
inline bool Start::has_game_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Start::set_has_game_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Start::clear_has_game_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Start::clear_game_state() {
  if (game_state_ != NULL) game_state_->::orwell::messages::GameState::Clear();
  clear_has_game_state();
}
inline const ::orwell::messages::GameState& Start::game_state() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return game_state_ != NULL ? *game_state_ : *default_instance().game_state_;
#else
  return game_state_ != NULL ? *game_state_ : *default_instance_->game_state_;
#endif
}
inline ::orwell::messages::GameState* Start::mutable_game_state() {
  set_has_game_state();
  if (game_state_ == NULL) game_state_ = new ::orwell::messages::GameState;
  return game_state_;
}
inline ::orwell::messages::GameState* Start::release_game_state() {
  clear_has_game_state();
  ::orwell::messages::GameState* temp = game_state_;
  game_state_ = NULL;
  return temp;
}
inline void Start::set_allocated_game_state(::orwell::messages::GameState* game_state) {
  delete game_state_;
  game_state_ = game_state;
  if (game_state) {
    set_has_game_state();
  } else {
    clear_has_game_state();
  }
}

// -------------------------------------------------------------------

// Stop

// optional bool shutdown = 1 [default = false];
inline bool Stop::has_shutdown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stop::set_has_shutdown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stop::clear_has_shutdown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stop::clear_shutdown() {
  shutdown_ = false;
  clear_has_shutdown();
}
inline bool Stop::shutdown() const {
  return shutdown_;
}
inline void Stop::set_shutdown(bool value) {
  set_has_shutdown();
  shutdown_ = value;
}

// optional bool video = 2 [default = true];
inline bool Stop::has_video() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stop::set_has_video() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stop::clear_has_video() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stop::clear_video() {
  video_ = true;
  clear_has_video();
}
inline bool Stop::video() const {
  return video_;
}
inline void Stop::set_video(bool value) {
  set_has_video();
  video_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace orwell

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_server_2dgame_2eproto__INCLUDED
